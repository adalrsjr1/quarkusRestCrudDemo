import http from 'k6/http';
import { check, sleep } from 'k6';
import { SharedArray } from 'k6/data';
import { Counter } from 'k6/metrics';

const requestRate = __ENV.REQUEST_RATE ? parseInt(__ENV.REQUEST_RATE) : 20; // Number of requests per second
const duration = __ENV.DURATION ? parseInt(__ENV.DURATION) : 3600; // Total duration of the test in seconds
const host = __ENV.HOST || 'localhost';
const port = __ENV.PORT || 30088;
const url = `http://${host}:${port}/fruits`;
const listRecordsLoopCount = __ENV.LIST_RECORDS_LOOP_COUNT ? parseInt(__ENV.LIST_RECORDS_LOOP_COUNT) : 5;

const data = new SharedArray('POST Data', function () {
    const timestamp = Date.now()
    return Array.from({ length: requestRate }, (_, i) => ({
        name: `fruit_${i}_${timestamp}_${Math.floor(Math.random() * 1000000)}`
    }));
});

const postHeaders = { 'Content-Type': 'application/json' };

export let errorCounter = new Counter('errors');

export const options = {
    scenarios: {
        constant_rate: {
            executor: 'constant-arrival-rate',
            rate: requestRate,
            timeUnit: '1s', // 20 requests per second
            duration: `${duration}s`,
            preAllocatedVUs: 100, // Initial number of VUs
            maxVUs: 200, // Maximum number of VUs
        },
    },
};

export default function () {
//    const postData = data[__ITER % requestRate];
    const postData = data[__VU % requestRate] + ${Date.now()};
//    const postData = `fruit-${Date.now()}-${Math.floor(Math.random() * 1337)}`
    const postResponse = http.post(url, JSON.stringify(postData), { headers: postHeaders });
    check(postResponse, {
        'POST status is 201': (r) => r.status === 201,
    });

    const postResponseBody = postResponse.json();
    const id = postResponseBody.id;

    const getResponse = http.get(`${url}/${id}`);
    check(getResponse, {
        'GET status is 200': (r) => r.status === 200,
    });

    const putResponse = http.put(`${url}/${id}`, JSON.stringify({ name: `fruit_${__ITER % requestRate}_${Date.now()}` }), { headers: postHeaders });
    check(putResponse, {
        'PUT status is 200': (r) => r.status === 200,
    });

    for (let i = 0; i < listRecordsLoopCount; i++) {
        const listResponse = http.get(url);
        check(listResponse, {
            'LIST status is 200': (r) => r.status === 200,
        });

        const listResponseBody = listResponse.json();
        if (listResponseBody.length > 0) {
            const randomRecordId = listResponseBody[Math.floor(Math.random() * listResponseBody.length)].id;
            const randomRecordGetResponse = http.get(`${url}/${randomRecordId}`);
            check(randomRecordGetResponse, {
                'GET random record status is 200': (r) => r.status === 200,
            });
        }
    }

    const deleteResponse = http.del(`${url}/${id}`);
    check(deleteResponse, {
        'DELETE status is 204': (r) => r.status === 204,
    });

    // Think time is already handled by constant-arrival-rate scenario
}

